"""
Type definitions for simulation engine.
"""

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from enum import Enum
import time
import uuid


class Direction(Enum):
    """Trade direction."""
    LONG = 1
    SHORT = -1
    NEUTRAL = 0


class ExitReason(Enum):
    """Trade exit reasons."""
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"
    TIME_EXIT = "time_exit"
    REVERSAL = "reversal"
    MANUAL = "manual"


@dataclass
class FormulaSignal:
    """Signal generated by a formula."""
    formula_id: int
    formula_name: str
    direction: int              # 1=LONG, -1=SHORT, 0=NEUTRAL
    confidence: float           # 0.0 to 1.0
    position_size_pct: float    # Recommended position as % of capital
    stop_loss_pct: float        # Stop loss percentage
    take_profit_pct: float      # Take profit percentage
    max_hold_seconds: float = 86400  # Max hold time (default 1 day)
    timestamp: float = field(default_factory=time.time)

    def __post_init__(self):
        if not self.timestamp:
            self.timestamp = time.time()


@dataclass
class Position:
    """Active trading position."""
    trade_id: str
    formula_id: int
    formula_name: str
    direction: int
    entry_price: float
    entry_timestamp: float
    position_size_pct: float
    position_btc: float
    position_usd: float
    stop_loss_price: float
    take_profit_price: float
    max_exit_time: float
    signal_strength: float

    @classmethod
    def from_signal(
        cls,
        signal: FormulaSignal,
        entry_price: float,
        capital: float
    ) -> 'Position':
        """Create position from signal."""
        trade_id = str(uuid.uuid4())[:12]
        position_usd = capital * signal.position_size_pct
        position_btc = position_usd / entry_price

        # Calculate SL/TP prices based on direction
        if signal.direction == 1:  # LONG
            stop_loss_price = entry_price * (1 - signal.stop_loss_pct)
            take_profit_price = entry_price * (1 + signal.take_profit_pct)
        else:  # SHORT
            stop_loss_price = entry_price * (1 + signal.stop_loss_pct)
            take_profit_price = entry_price * (1 - signal.take_profit_pct)

        return cls(
            trade_id=trade_id,
            formula_id=signal.formula_id,
            formula_name=signal.formula_name,
            direction=signal.direction,
            entry_price=entry_price,
            entry_timestamp=signal.timestamp,
            position_size_pct=signal.position_size_pct,
            position_btc=position_btc,
            position_usd=position_usd,
            stop_loss_price=stop_loss_price,
            take_profit_price=take_profit_price,
            max_exit_time=signal.timestamp + signal.max_hold_seconds,
            signal_strength=signal.confidence,
        )

    def check_exit(self, current_price: float, current_time: float) -> Optional[ExitReason]:
        """Check if position should exit."""
        if self.direction == 1:  # LONG
            if current_price <= self.stop_loss_price:
                return ExitReason.STOP_LOSS
            if current_price >= self.take_profit_price:
                return ExitReason.TAKE_PROFIT
        else:  # SHORT
            if current_price >= self.stop_loss_price:
                return ExitReason.STOP_LOSS
            if current_price <= self.take_profit_price:
                return ExitReason.TAKE_PROFIT

        if current_time >= self.max_exit_time:
            return ExitReason.TIME_EXIT

        return None

    def calculate_pnl(self, exit_price: float) -> tuple:
        """Calculate PnL for position.

        Returns:
            tuple: (pnl_usd, pnl_pct)
        """
        if self.direction == 1:  # LONG
            pnl_pct = (exit_price / self.entry_price - 1) * 100
        else:  # SHORT
            pnl_pct = (1 - exit_price / self.entry_price) * 100

        pnl_usd = self.position_usd * (pnl_pct / 100)
        return pnl_usd, pnl_pct


@dataclass
class TradeResult:
    """Completed trade result."""
    trade_id: str
    session_id: str
    formula_id: int
    formula_name: str
    direction: int
    signal_strength: float

    # Timestamps
    signal_timestamp: float
    entry_timestamp: float
    exit_timestamp: float

    # Prices
    signal_price: float
    entry_price: float
    exit_price: float

    # Position
    position_size_pct: float
    position_btc: float
    position_usd: float

    # Risk parameters
    stop_loss_pct: float
    take_profit_pct: float

    # Result
    pnl_usd: float
    pnl_pct: float
    exit_reason: str

    # Verification
    exchange_price_at_signal: float = 0.0
    slippage_pct: float = 0.0
    prediction_correct: bool = False

    @property
    def is_win(self) -> bool:
        return self.pnl_usd > 0


@dataclass
class SimulationTrade:
    """Trade record for database storage."""
    trade_id: str
    session_id: str
    mode: str

    signal_timestamp: float
    entry_timestamp: Optional[float] = None
    exit_timestamp: Optional[float] = None

    formula_id: int = 0
    formula_name: str = ""
    direction: int = 0
    signal_strength: float = 0.0

    signal_price: float = 0.0
    entry_price: Optional[float] = None
    exit_price: Optional[float] = None

    position_size_pct: float = 0.0
    position_btc: Optional[float] = None
    position_usd: Optional[float] = None

    stop_loss_pct: float = 0.0
    take_profit_pct: float = 0.0

    pnl_usd: Optional[float] = None
    pnl_pct: Optional[float] = None
    exit_reason: Optional[str] = None

    exchange_price_at_signal: Optional[float] = None
    slippage_estimated: Optional[float] = None
    prediction_correct: Optional[int] = None


@dataclass
class SimulationSession:
    """Session tracking."""
    session_id: str
    mode: str
    start_timestamp: float
    end_timestamp: Optional[float] = None

    initial_capital: float = 10000.0
    final_capital: Optional[float] = None
    kelly_fraction: float = 0.25

    formula_ids: List[int] = field(default_factory=list)

    total_trades: int = 0
    total_wins: int = 0
    total_losses: int = 0
    total_pnl_usd: float = 0.0

    max_drawdown_pct: float = 0.0
    sharpe_ratio: Optional[float] = None
    win_rate: Optional[float] = None

    @classmethod
    def create(
        cls,
        mode: str,
        initial_capital: float,
        kelly_fraction: float = 0.25,
        formula_ids: List[int] = None
    ) -> 'SimulationSession':
        """Create new session."""
        return cls(
            session_id=str(uuid.uuid4())[:8],
            mode=mode,
            start_timestamp=time.time(),
            initial_capital=initial_capital,
            kelly_fraction=kelly_fraction,
            formula_ids=formula_ids or [],
        )

    def update_stats(self, trade: TradeResult):
        """Update session stats with trade result."""
        self.total_trades += 1
        self.total_pnl_usd += trade.pnl_usd

        if trade.pnl_usd > 0:
            self.total_wins += 1
        else:
            self.total_losses += 1

        if self.total_trades > 0:
            self.win_rate = self.total_wins / self.total_trades


@dataclass
class FormulaPerformance:
    """Per-formula performance tracking."""
    session_id: str
    formula_id: int
    formula_name: str

    trades: int = 0
    wins: int = 0
    losses: int = 0
    total_pnl: float = 0.0

    @property
    def win_rate(self) -> float:
        return self.wins / self.trades if self.trades > 0 else 0.0

    @property
    def avg_pnl(self) -> float:
        return self.total_pnl / self.trades if self.trades > 0 else 0.0
